<!DOCTYPE html>
<html>
    <head>
        <title>Dynamic Programming</title>
        <meta charset='utf-8' />
        <link rel='stylesheet' type='text/css' href='./css/common.css' />
        <script href='./js/elements-query.js'></script>
        <script href='./js/common.js'></script>
    </head>
    <body>
        <h1 class='title'>Dynamic Programming<span class='chn'>动态规划</span></h1>
        <details class='card'>
            <summary>General Theory of Dynamic Programming<span class='chn'>动态规划概述</span></summary>
            <hr />
            <p><span class='chn'>动态规划是一种算法的设计思想。方法是通过组合子问题的解来求解原问题。</span>(programming<span class='chn'>是指类似于填表格来求解问题的方法</span>)</p>
            <p><span class='chn'>不难发现这个思想与分治思想有着很相似的地方——求解子问题，并用子问题的解来求出原问题的解。区别在于分治在划分子问题时，子问题是互不相交的，而在动态规划思想中，不同的子问题一般拥有公共的子子问题。在动态规划问题中，每个子问题只会被求解一次然后将解存在一个表格中以避免重复计算。</span></p>
            <p><span class='chn'>动态规划一般用于求解最优化问题</span>(optimization problem)<span class='chn'>。</span></p>
            <p><span class='chn'>动态规划算法的设计一般采用下面的思路和步骤：</span></p>
            <ol class='chn'>
                <li>刻画最优解的结构特征</li>
                <li>递归定义最优解的值</li>
                <li>计算最优解的值，通常采用自底向上方法</li>
                <li>构造最优解(可选)</li>
            </ol>
            <p><span class='chn'>上述步骤2就是常说的构造状态转移方程。</span></p>
            <h4>eg.<span class='chn'>钢条切割问题</span></h4>
            <h4>eg.<span class='chn'>矩阵链问题</span></h4>
            <h3 class='chn'>动态规划原理</h3>
            <p><span class='chn'>适合应用动态规划方法的问题应该具备两个要素：最优子结构与子问题重叠。</span></p>
            <p class='def'><span class='chn'>如果一个问题的额最优解包含其子问题的最优解，我们称此问题具有最有子结构性质。</span></p>
            <p><span class='chn'>如果一个问题不具有最优子结构的性质，那么显然我们是不能对其使用动态规划的方法的。当然一个具有最优子结构的问题也可能可以通过贪心来解决。而一般在挖掘最优子结构性质的过程中，会遵循下面的模式：</span></p>
            <ol>
                <li><span class='chn'>证明问题最优解的第一个组成部分是做出一个选择。做出这次选择会产生1个或者多个待解决的子问题。</span></li>
                <li><span class='chn'>对于一个给定问题，在其可能的第一步选择中，假定已经知道了哪种选择才会得到最优解，且不关心具体的得到这种选择的方法，仅仅假定已经知道了这样的选择。</span></li>
                <li><span class='chn'>给定可获得最优解的选择后，确定这次选择会产生哪些问题，且如何刻画子问题空间。</span></li>
                <li><span class='chn'>证明作为构成原问题最优解的部分， 子问题的解就是本身的最优解。</span></li>
            </ol>
            <p><span class='chn'>要注意的是，这些子问题应该具有相互无关性</span>(independence)<span class='chn'>。</span></p>
            <h4>eg.<span class='chn'>无权最短路与无权最长简单路</span></h4>
        </details>
        <details class='card'>
            <summary>Common models<span class='chn'>常见动态规划问题类型</span></summary>
            <hr />
            <h3><span class='chn'>基本递推</span></h3>
            <p><span class='chn'>这种类型的问题通常比较简单，根据实际情况枚举可能的子问题并组合答案即可。</p>
            <h4>eg.<a href='http://vijos.org/p/1121' target='_blank'>vijos 1121[NOIP2002]<span class='chn'>马拦过河卒</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>注意边界判定</span></p>
            </details>
            <h3><span class='chn'>背包</span></h3>
            <p><span class='chn'>即用一个有容量的背包来装物品，要求一个总价值最大的装包方案。根据物品可以取的次数可以分为01背包，无限背包，多重背包等种类。</span></p>
            <h4>eg.<a href='http://vijos.org/p/1133' target='_blank'>vijos 1133[NOIP2001]<span class='chn'>装箱问题</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>简单的背包</span></p>
            </details>
            <h4>eg.<a href='http://vijos.org/p/1179' target='_blank'>vijos 1179[NOIP1999]<span class='chn'>邮票面值设计</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p>dfs+<span class='chn'>无限背包</span></p>
            </details>
            <h3><span class='chn'>区间</span>DP</h3>
            <p><span class='chn'>这种类型的问题通常与一个区间有关。即在一定的区间内取一个最优解。一个区间的最优解可以由其子区间的最优解构造。一种常见的状态转移方程是</span><var>f[l, r] = opt(merge(f[l, k], f[k + 1, r])) (l&le;k&le;r).</var>
            <var>opt</var><span class='chn'>表示取最优值。</span><var>merge</var><span class='chn'>是将子问题的解合并成其父问题的解的方法。</span></p>
            <h4>eg.<a href='http://vijos.org/p/1100' target='_blank'>vijos 1100[NOIP2003][<span class='chn'>提高</span>]<span class='chn'>加分二叉树</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>对任意一棵树枚举其根节点，取最优解</span></p>
            </details>
            <h4>eg.<a href='http://vijos.org/p/1117' target='_blank'>vijos 1117[NOIP2001][<span class='chn'>提高</span>]<span class='chn'>数的划分</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>注意划分的方法，要不重复，不遗漏</span></p>
            </details>
            <h3>LIS<span class='chn'>最长不上升子序列</span></h3>
            <p><span class='chn'>这种类型的问题通常是要求一个序列的最长不上升子序列。常见的状态转移方程是</span><var>f[i] = max(f[k]) + 1, (1&le;k&le;i, data[k] <= data[i])</var>.</p>
            <h4>eg.<a href='http://vijos.org/p/1098' target='_blank'>vijos 1098[NOIP2004][<span class='chn'>提高</span>]<span class='chn'>合唱队形</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>两次LIS</span></p>
            </details>
            <h3><span class='chn'>状态压缩动态规划</span></h3>
            <p><span class='chn'>这种问题属于偏难的题目，而难点往往在于对情况的分析与对状态的压缩方法的选择。</p>
            <h4>eg.<a href='http://vijos.org/p/1002' target='_blank'>vijos 1002[NOIP2005][<span class='chn'>提高</span>]<span class='chn'>过河</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>删去无用的空白长度</span></p>
            </details>
        </details>
        <details class='card'>
            <summary>Code for referrence<span class='chn'>参考代码</span></summary>
            <ul>
                <li><a href='./problemset/vijos/1121/main.cpp'>vijos 1121<span class='chn'>马拦过河卒</span></a></li>
                <li><a href='./problemset/vijos/1133/main.cpp'>vijos 1133<span class='chn'>装箱问题</span></a></li>
                <li><a href='./problemset/vijos/1179/main.cpp'>vijos 1179<span class='chn'>邮票面值设计</span></a></li>
                <li><a href='./problemset/vijos/1100/main.cpp'>vijos 1100<span class='chn'>加分二叉树</span></a></li>
                <li><a href='./problemset/vijos/1117/main.cpp'>vijos 1117<span class='chn'>数的划分</span></a></li>
                <li><a href='./problemset/vijos/1098/main.cpp'>vijos 1098<span class='chn'>合唱队形</span></a></li>
                <li><a href='./problemset/vijos/1002/main.cpp'>vijos 1002<span class='chn'>过河</span></a></li>
            </ul>
        </details>
    </body>
</html>
