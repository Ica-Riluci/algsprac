<!DOCTYPE html>
<html>
    <head>
        <title>Dynamic Programming</title>
        <meta charset='utf-8' />
        <link rel='stylesheet' type='text/css' href='./css/common.css' />
        <script href='./js/elements-query.js'></script>
        <script href='./js/common.js'></script>
    </head>
    <body>
        <h1 class='title'>Dynamic Programming<span class='chn'>动态规划</span></h1>
        <details class='card'>
            <summary>General Theory of Dynamic Programming<span class='chn'>动态规划概述</span></summary>
            <hr />
            <p><span class='chn'>动态规划是一种算法的设计思想。方法是通过组合子问题的解来求解原问题。</span>(programming<span class='chn'>是指类似于填表格来求解问题的方法</span>)</p>
            <p><span class='chn'>不难发现这个思想与分治思想有着很相似的地方——求解子问题，并用子问题的解来求出原问题的解。区别在于分治在划分子问题时，子问题是互不相交的，而在动态规划思想中，不同的子问题一般拥有公共的子子问题。在动态规划问题中，每个子问题只会被求解一次然后将解存在一个表格中以避免重复计算。</span></p>
            <br />
            <p><span class='chn'>动态规划一般用于求解最优化问题</span>(optimization problem)<span class='chn'>。</span></p>
            <p><span class='chn'>动态规划算法的设计一般采用下面的思路和步骤：</span></p>
            <ol class='chn'>
                <li>刻画最优解的结构特征</li>
                <li>递归定义最优解的值</li>
                <li>计算最优解的值，通常采用自底向上方法</li>
                <li>构造最优解(可选)</li>
            </ol>
            <p><span class='chn'>上述步骤2就是常说的构造状态转移方程。</span></p>
            <h4>eg.<span class='chn'>钢条切割问题</span></h4>
            <h4>eg.<span class='chn'>矩阵链问题</span></h4>
            <h3 class='chn'>动态规划原理</h3>
        </details>
        <details class='card'>
            <summary>Common models<span class='chn'>常见动态规划问题类型</span></summary>
            <hr />
            <h3><span class='chn'>区间</span>DP</h3>
            <p><span class='chn'>这种类型的问题通常与一个区间有关。即在一定的区间内取一个最优解。一个区间的最优解可以由其子区间的最优解构造。一种常见的状态转移方程是</span><var>f[l, r] = opt(merge(f[l, k], f[k + 1, r])) (l&le;k&le;r).</var>
            <var>opt</var><span class='chn'>表示取最优值。</span><var>merge</var><span class='chn'>是将子问题的解合并成其父问题的解的方法。</span></p>
            <h4>eg.<a href='http://vijos.org/p/1100' target='_blank'>vijos 1100[NOIP2003][<span class='chn'>提高</span>]<span class='chn'>加分二叉树</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>对任意一棵树枚举其根节点，取最优解</span></p>
            </details>
            <h3>LIS<span class='chn'>最长不上升子序列</span></h3>
            <p><span class='chn'>这种类型的问题通常是要求一个序列的最长不上升子序列。常见的状态转移方程是</span><var>f[i] = max(f[k]) + 1, (1&le;k&le;i, data[k] <= data[i])</var>.</p>
            <h4>eg.<a href='http://vijos.org/p/1098' target='_blank'>vijos 1098[NOIP2004][<span class='chn'>提高</span>]<span class='chn'>合唱队形</span></a></h4>
            <details class='incard'>
                <summary class='chn'>提示</summary>
                <hr />
                <p><span class='chn'>两次LIS</span></p>
            </details>
            <h3><span class='chn'>背包</span></h3>
            <p><span class='chn'>即用一个有容量的背包来装物品，要求一个总价值最大的装包方案。根据物品可以取的次数可以分为01背包，无限背包，多重背包等种类。</span></p>
        </details>
    </body>
</html>
